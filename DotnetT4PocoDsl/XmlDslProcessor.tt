<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
//Generated file. Do not edit it manually.
using System;
<#
    //Define your inputs below
    var inputs = new[]
    {
        "Commands.xml",
        "Events.xml"
    };

    //Processing inputs
    foreach (var input in inputs)
    {
        var source = Host.ResolvePath(input); //Resolve actual path of the input file
        var sourceDoc = XDocument.Load(source);
        #>

namespace <#= sourceDoc.Root.Attribute("namespace").Value #>
{<#
    foreach (var classDefElement in sourceDoc.Root.Elements()) //Each element in the doc is a DSL class definition
    {
        var propertyDefAttribs = classDefElement.Attributes().ToList(); //Each attribute is a property of the DSL class
        #>

    public class <#= classDefElement.Name #> : IEquatable<<#= classDefElement.Name #>>
    {
<#
        foreach (var property in propertyDefAttribs)
        {
            #>        public <#= property.Value #> <#= property.Name #> { get; set; }
<#
        }
        var constructorArgs = propertyDefAttribs
            .Select(property => property.Value + " " + property.Name.ToString().ToLower() + " = default(" + property.Value + ")");
        #>

        public <#= classDefElement.Name #>(<#= String.Join(", ", constructorArgs) #>)
        {
<#
        for (var i = 0; i < propertyDefAttribs.Count(); i++)
        {
            var property = propertyDefAttribs.ElementAt(i);
            #>            <#= property.Name #> = <#= property.Name.ToString().ToLower() #>;
<#
        }
#>
        }

        public bool Equals(<#= classDefElement.Name #> other)
        {
            return
<#
        var equalityParts = propertyDefAttribs.Select(property =>
        {
            if (property.Value == "XElement") return property.Name + ".CompareContent(" + "other." + property.Name + ")";
            if (property.Value.StartsWith("IDictionary")) return property.Name + ".SequenceEqual(" + "other." + property.Name + ")";
            return property.Name + " == " + "other." + property.Name;
        });

            #>                <#= String.Join(" &&\r\n                ", equalityParts) #>;
        }

        public override string ToString()
        {
<#
        var formatPart = new StringBuilder();
        var argumentsPart = new StringBuilder();
        formatPart.Append("<").Append(classDefElement.Name).Append(" ");
        for (var i = 0; i < propertyDefAttribs.Count(); i++)
        {
            var nextI = i + 1;
            var property = propertyDefAttribs.ElementAt(i);
            formatPart.Append(property.Name).Append(": {" + i + "}").Append(nextI < propertyDefAttribs.Count() ? ", " : "");
            argumentsPart.Append(property.Name).Append(nextI < propertyDefAttribs.Count() ? ", " : "");
        }
        formatPart.Append(">");
        #>
            return string.Format("<#= formatPart #>", <#= argumentsPart #>);
        }
    }
<#
    }
#>
}<#
    }
#>